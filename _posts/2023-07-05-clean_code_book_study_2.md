---
layout: article
title: Clean Code✨ Book Study 2
tags: Book_Study Clean_Code
aside:
  toc: true
---



## Chapter 11. 시스템

#### 초기화 지연 (Lazy Initialization)
  - 필드의 초기화 시점을 그 값이 처음 필요할 때까지 늦추는 기법
  - 초기화가 필요한 경우에만 초기화를 수행 -> 비용이 많이 드는 작업 및 복잡한 객체를 생성할 때 유용!
  - python class에 @property가 예시

#### 계산 지연 (Lazy Evaluation)
  - 계산의 결과값이 필요할 때까지 계산을 늦추는 기법
  - 특정한 계산이 필요할 때까지 연산을 지연시킴 -> 불필요한 계산을 피할 수 있게되어 메모리 사용을 줄이고, 효율적인 연산이 가능
  - python의 generator가 예시!
  - [참고](https://medium.com/sjk5766/lazy-evaluation%EC%9D%84-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90-411651d5227b)


#### Main 분리
<img width="801" alt="image" src="https://github.com/2cong/2cong/assets/60612551/e36fd4bf-7c62-4373-a088-7d63b1737841">

- 시스템 생성과 시스템 사용을 분리하는 방법
- 생성과 관련된 코드는 모두 main / main이 호출하는 모듈에 두기
- main 함수에서 시스템에 필요한 객체 생성 → Application에서 실행
  - Application은 main이나 객체가 생성되는 과정을 알 수 없음!
  - Application은 객체가 생성 되었다고 가정하고 사용할 뿐

#### 팩토리
<img width="911" alt="image" src="https://github.com/2cong/2cong/assets/60612551/ee87cdeb-7b58-44e3-8e45-acfcaf228ae2">

- 객체가 생성되는 시점을 Application이 결정해야 할 때가 있음 → 이 때 Abstract Factory 패턴을 사용하면 좋음
- 객체 (이미지에서는 LineItem) 생성 시점은 Application이 결정하지만 Application은 객체 생성 코드를 알 수 없음
  - 객체 생성 방법은 main에 있는 Factory 구현 코드가 알고 있음!

#### 의존성 주입
- 제어 역전
  - 소프트웨어 개발에서 일반적으로 객체의 생성과 생명 주기 관리를 개발자가 아닌 프레임워크나 컨테이너에 위임하는 것

- 의존성 주입
  - 객체 간의 의존성을 외부에서 설정하고 주입하는 디자인 패턴
  - 객체 간의 관계에서 하나의 객체가 다른 객체에 의존할 때, 이 의존성을 코드 내부에서 직접 생성하는 것이 아니라 외부에서 주입받도록 하는 것
  - 의존성을 주입하는 방법으로 setter 메소드나 생성자 등을 제공함


이 장에서는 코드를 짤 때 모듈을 잘 나누고 관심사를 잘 분리하라고 했다. 핵심 로직과 관심사 등을 분리하는게 책으로 읽을 때는 이해가 되지만 막상 코드를 짜려면 잘 와닿지는 않는 것 같다. 전체적으로 어려운 챕터였던 것 같다 🥲<br>
다음에 또 읽을 일이 있다면 그 때는 지금보다 더 잘 이해하고 싶은 챕터다..!

----

## Chapter 12. 창발성

#### 소프트웨어 설계 품질을 높여주는 네 가지 설계 규칙
- 모든 테스트를 실행한다
- 중복을 없앤다
- 프로그래머 의도를 표현한다
- 클래스와 메소드 수를 최소로 줄인다

#### TEMPLATE METHOD 패턴
- 중복 제거에 사용될 수 있음
- 여러 클래스에서 공통으로 사용하는 메서드를 템플릿화 하여 상위 클래스에서 정의하고, 하위 클래스마다 세부 동작 사항을 다르게 구현하는 패턴
- [좋은 블로그](https://hudi.blog/template-method-pattern/)

책에서는 위의 4가지 설계 규칙을 잘 지키면 좋은 소프트웨어를 설계할 수 있다고 했다. 모두 간단해보이지만 실제로 적용하면 어려운 내용들인 것 같다 🥲<br>
나는 중복을 줄이는 부분이 특히 어려웠는데, 요구 사항이 소소하게 다르거나 받아야 할 인자 등이 조금씩 달라서 공통 로직으로 만드는 것이 복잡했던 것 같다. 하지만 많은 중복 로직은 추가 작업을 만들 수 있으니 이 부분을 줄이기 위해 고민해봐야겠다. <br>
또 중복 로직을 생성하며 메소드가 너무 많아지게 되는거 아닌가 하는 고민이 있었는데, 책의 **"클래스와 함수 수를 줄이는 작업도 중요하지만，테스트 케이스를 만들고 중복을 제거하고 의도를 표현하는 작업이 더 중요하다는 뜻이다."** 라는 부분에서 답을 얻을 수 있어서 도움이 된 챕터였다!!


------
## Chapter 13. 동시성

#### 동시성
- 결합(coupling)을 없애는 전략
  - 무엇(what)과 언제(when)를 분리하는 전략
  - 무엇과 언제를 분리하면 응용 프로그램 구조와 효율이 극적으로 나아짐
- 응답 시간 및 작업 처리량 개선에 때문에 동시성 구현이 필요함
- 동시성이 항상 성능을 높여주는 것은 X
  - 성능 향상 되는 경우
    - 여러 스레드가 프로세스를 공유할 수 있는 상황 (예시 : 파일 읽는 스레드 / 데이터 가공하는 스레드 -> 파일을 읽는 동안 데이터를 가공하는 스레드는 프로세서를 사용하여 독립적인 계산을 동시에 처리)
    - 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우 (프로세스를 병렬로 처리할 수 있는 경우 -> 각 계산이 독립적인 경우)


#### 실행 모델 이해하기

- 동시성 기본 용어
<br>
<img width="662" alt="image" src="https://github.com/2cong/2cong/assets/60612551/85c1f1fb-874a-4845-8381-e7ee0288ab31">

<br>

- 생산자 - 소비자 패턴 (Producer - Consumer) 
![image](https://github.com/2cong/2cong/assets/60612551/f031f3eb-416a-4767-9b15-6ce0de9b04ff)
- [이미지 출처](https://jenkov.com/tutorials/java-concurrency/producer-consumer.html)

 - 생산자 스레드 : 정보를 생성하여 대기열 (buffer나 queue) 에 넣는다
 - 소비자 스레드 : 대기열에서 정보를 가져와서 사용한다
 - 대기열 : 한정된 자원
   - 생산자 스레드는 대기열에 빈 공간이 생겨야 정보를 넣을 수 있음 (빈 공간이 생길 때까지 기다려야 함)
   - 소비자 스레드는 대기열에 정보가 채워질 때까지 기다려야 함

<br>

- 독자 - 저자 문제 (Readers - Writers)
  - 여러 개의 reader(독자)와 writer(저자)가 동시에 공유 자원에 접근하는 상황에서 발생할 수 있는 문제
    - 여러 개의 reader는 동시에 자원을 읽을 수 있음
    - 오직 하나의 writer만 자원을 쓸 수 있음
    - 쓰기 작업이 진행 중일 때에는 어떠한 reader도 접근 불가
    - reader나 writer가 자원에 접근하지 못해서 기아 문제가 발생할 수 있음

<br>

- Dinging Philosophers
  - 조건 )
    1. 여러 철학자들이 원형 테이블에 앉아 있음
    2. 각 철학자는 식사와 생각이라는 두 가지 활동을 번갈아 가며 함
    3. 철학자는 식사를 하기 위해서는 두 개의 인접한 포크(또는 젓가락)를 사용해야 함
    4. 모든 철학자가 동시에 자신의 오른쪽 포크를 집은 후 왼쪽 포크를 잡는 경우 → 교착 상태(deadlock)가 발생할 수 있음

<br>  

다중 스레드 코드는 구현하기 어렵기 때문에 각별히 깨끗하게 코드를 짜줘야 한다! 
- 스레드 코드를 테스트할 때는 전적으로 스레드 코드만 테스트 하기
- 동시성 오류를 일으키는 잠정적인 원인을 이해하기..!
- 임계 영역을 잘 보호하기
- 다양한 테스트를 해보기

----
## Chapter 14. 점진적인 개선

- 클린 코드를 짜려면 먼저 지저분한 코드를 짠 뒤에 정리해야 함
  - 조금씩 고치고 테스트로 잘 돌아가는지 확인 반복!!
- 소프트웨어 설계 → 분할만 잘해도 품질이 크게 높아짐!
- 적절한 장소를 만들어서 코드만 분리해도 설계가 좋아질 수 있음
- 관심사를 분리하면 코드를 이해하고 보수하기 훨씬 더 쉬워짐

이 챕터에서는 코드를 짤 때 처음부터 완벽하게 짤 수 없으니 점직적으로 개선해 나가라고 했다. 처음부터 완벽하게 짜려고 하다보면 개발 시간이 지체되는 것 같다. 여기서 주의할 점은 코드를 그저 돌아가는 상태로 두지 않는 것이다..!
코드가 돌아가는 상태가 되고 어느정도 가독성이 있는 상태가 되면 코드를 꼼꼼하게 확인하지 않게 되는 것 같다 🥲 마지막까지 내가 짠 코드를 잘 확인하고 클린한지 분리할 곳이 있는지 한번 더 살펴보도록 노력해야지 👊🏻 <br>

저자는 프로그램을 망치는 가장 좋은 방법 중 하나가 개선이라는 이름 아래 구조를 크게 뒤집는 행위라고 했으나 나는 가끔은 필요한 작업이라고 생각한다..! 다만 이 경우에 저자가 말했듯이 테스트 코드를 잘 이용해야한다!
이렇게 테스트를 활용하면 큰 수정이 있어도 수정된 코드가 제대로 돌아가고 있는지를 확인할 수 있어서 안심된다..! 나도 코드 수정 후 기존의 테스트가 잘 통과하는지를 꼭 확인하는데 이럴 때마다 테스트가 정말 중요하다고 느끼게 된다.
테스트를 짤 때가 되면 귀찮아지지만 테스트의 중요성을 다시 한번 인지하고 다양한 부분을 확인할 수 있도록 꼼꼼하게 짜도록 해야겠다..!! 💪



---
<br>

이 책을 처음 읽었을 때는 이해가 안가는 부분이 많았다. 이번에 읽을 때는 처음 읽었을 때는 잘 모르겠던 용어들이나 내용들이 전보다 잘 이해되었다. 완벽하게 이해한 것은 아니지만..🥹 그래도 그 사이에 은은하게 성장했구나를 느끼게 되어서 뿌듯했다 ...!
클린한 코드를 짜는건 항상 어려운 것 같다. 저자가 말한 것 처럼 클린한 코드를 짜려고 꾸준히 연습하는 것이 제일 중요한 것 같다. 좋은 코드를 많이 보고 항상 노력하도록 해야지!! 
