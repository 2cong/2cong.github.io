---
layout: article
title: Clean Code✨ Book Study 1
tags: Book_Study Clean_Code
aside:
  toc: true
---

북 스터디를 하며 이전에 읽었던 **클린코드 : 애자일 소프트웨어 장인 정신**를 다시 읽기로 했다.

전에 읽었을 때는 이해보다는 정리에 초점을 맞췄던 것 같다 🫠 이번에는 정리보다는 이해하는 것을 목표로 삼아야겠다!! <br>
아래에는 책을 읽으며 이해가 잘 안되었던 부분 또는 느낀 점을 정리해보았다 ~!

---

## Chapter 1. Clean Code
나쁜 코드는 생산성을 떨어뜨린다. 일단 이해하는데 많은 시간이 소모되고, 작은 수정을 위해 전체 코드를 뜯어고쳐야 할 때도 있다. 이상하게 얽혀있는 코드를 리팩토링하느냐고 일주일 이상의 시간을 낭비한 적도 있다.️
이상하게 설계되어 이미 여기저기에서 사용되고 있는 코드는 수정 범위가 너무 커서 고치기도 힘들다.

이 책에서 나쁜 코드를 깨진 유리창에 비유한다. [깨친 유리창 이론](https://ko.wikipedia.org/wiki/%EA%B9%A8%EC%A7%84_%EC%9C%A0%EB%A6%AC%EC%B0%BD_%EC%9D%B4%EB%A1%A0)이란 사소한 무질서를 방치하면 큰 문제로 이어질 가능성이 높다는 의미를 담고있는데, 
사소한 나쁜 코드가 더욱 나쁜 코드를 야기한다는 뜻이다. 이렇게 나쁜 코드가 쌓여 엉망인 상태가 되어버린 코드는 고쳐나가는 과정이 너무 막막하고 아찔해서 방관하고 싶어진다. 그러니 코드를 처음 짤 때부터 잘 짜는 것이 중요하다!

잘못 짠 코드는 다른 사람들, 그리고 미래의 나를 힘들게 한다. 이 사실을 명심하고 코드를 짤 때 항상 클린하게 짜기 위해 노력해야겠다..! 클린한 코드를 짜는 방법을 배워도 실제로 적용하기는 힘든 것을 알고 있다. 그래도 계속 연습하고 노력해야지 💪

---

## Chapter 2. 의미 있는 이름
내가 이름을 짓기 어려웠던 경우
- 의미를 잘 내포하게 만들면 이름이 너무 길어지고, 또 길이를 줄이면 너무 함축되는 경우
  - 함축된 이름보다는 길어도 명확한 이름이 낫다는 사실을 배웠다..! 역시 명확한 것이 제일 좋은듯!!
  - 하지만 이름이 너무 길면 가독성이 떨어질 수 있으니 적당한 선에서 잘 표현하기 위해 노력하기!
  - 이런 경우 **의미 있는 맥락을 추가**하면 좋을 것 같다 
　
<br>
　
- 데이터 가공이나 전달을 위해 묶인(?) 데이터 등
  - ~Info, ~Data 외에는 설명이 어려운.. 그런 느낌의 변수나 자료들..! 🫣
  - 이런 내용은 어떻게 변수명을 지으면 좋을지 아직은 잘 모르겠다 🙊 하지만 Info, Data 등의 이름은 명확하지 않은 것이 사실이다. 좀 더 명확하게 표현할 수 있도록 노력해야지
　
<br>
　
- 함수가 여러가지 일을 하고 있어서 이름 짓기 어려웠던 경우
  - 함수 / 클래스를 잘 쪼개도록 하자..!

---

## Chapter 3. 함수
함수는 한 가지의 일을 해야한다고 한다. 그 한가지의 기준이 항상 너무 애매했는데 책에서 잘 정리해주었다.
- 함수가 하는 **한 가지 일**의 기준
  - 지정된 함수 이름 아래에서 **추상화 수준이 하나인 단계**만 수행하는 것 → 함수 내 모든 문장이 **동일한 추상화 수준**에 있어야 함!
  - 더 이상 의미를 유지하며 줄이기 불가능한 정도
  - 의미 있는 이름으로 다른 함수를 추출 가능하면 그 함수는 여러 가지 작업을 하는 것

<br>
책에 있던 아래의 문장이 이해가 잘 가지 않아서 무슨 의미인지 찾아보았다.
> 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다.

- 추상화 수준이란? 
   - 추상화 수준 → level of abstraction
   - 추상화 수준이 높다 : 노출되는 정보(구현 내용, 세부사항 등)가 적다 (**higher level → less detail**)
   - 추상화 수준이 낮다 : 노출되는 정보가 많다 (**lower level → more detail**)
   - [참고 자료 1](https://www.pcmag.com/encyclopedia/term/level-of-abstraction), [참고 자료 2](https://www.youtube.com/watch?v=LOgfAWwair4)
    　
<br>
　
- 추상화 수준이 하나인 단계만 수행?
   - 함수 안에서 수행되는 모든 문장의 추상화 수준이 동일해야 함
   - 함수의 내부 로직이 모두 동일한 추상화 수준에서 동작

---

## Chapter 6. 객체와 자료 구조
- 객체 : 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개
  - 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉬움
  - 새로운 함수 추가하기 어려움 → 모든 클래스를 고쳐야 함
  - **새로운 자료 타입**이 필요한 경우에 적합
　
<br>
　
- 자료 구조 : 자료를 그대로 공개하며 별다른 함수 제공 X
  - 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉬움
  - 새로운 자료 구조 추가하기 어려움 → 모든 함수를 고쳐야 함
  - **새로운 함수**가 필요한 경우에 적합
　
<br>
　
- 활성 레코드
  - DTO(자료 전달 객체)의 특수한 형태
  - 데이터베이스의 개별 레코드를 객체로 표현 (데이터베이스 테이블 등의 자료를 직접 변환한 결과)
    - 해당 객체를 통해 데이터베이스와 상호작용할 수 있는 기능을 제공
  - 조회 / 설정 함수 외에 save, find 같은 탐색 함수를 제공하는 경우도 많음
  - 활성 레코드는 자료 구조임! 객체로 취급해서 비즈니스 로직을 추가하지 말 것!!

### 디미터 법칙
- 객체 간 결합도를 낮추고 응집도를 높이기 위한 방법
  - 다른 객체의 내부 구조에 대한 지나친 의존성 피하기
　
<br>
　
- 클래스 C의 메소드 f는 아래 객체의 **메소드**만 호출 가능
  - 클래스 C
  - f가 생성한 객체
  - f의 인수로 넘어온 객체
  - C 인스턴스 변수에 저장된 객체
　
<br>
　
- 위 객체의 메소드가 **반환하는 객체의 메소드는 호출 X**

#### 기차 충돌
- 코드에서 메서드 호출이 연속적으로 이어지는 형태를 의미
- 하나의 객체에서 다른 객체의 메서드를 연속적으로 호출하는 것
  - 예시 : object1.method1().method2().method3()
- 객체 간의 의존성을 증가시키고, 객체 간의 결합도를 높이게 됨 → 따라서 피해야 함!

#### 구조체 감추기
- 책의 예시에서 ctxt.getAbsolutePathOfScratchDirectoryOption( ); → ctxt 객체에 공개해야 하는 메소드가 너무 많다고 함
- 이 부분이 잘 이해가 안돼서 찾아봄 (with chat gpt 🤗)
- ctxt 객체에 공개해야하는 메소드가 많다?
  - 위의 함수는 `final String outputDir = ctxt.getOptions( ).getScratchDir( ).getAbsolutePath( );` 를 내포함
  - 이 메소드는 "options" 객체와 , "scratchdir" 객체에 정의된 메소드를 사용해야 함
  - ctxt가 options, ScratchDir의 내용을 알아야 함 → 좋지 않은 방식!

시스템을 구성할 때 자료구조 및 객체 중 적절한 것을 잘 선택해서 사용하도록 노력하기!! 🤓

---

## Chapter 7. 오류 처리
### 자바의 예외

<img width="756" alt="image" src="https://github.com/2cong/2cong/assets/60612551/e6d15bba-f874-4b0b-b2ce-3d9d9b996575">

[출처](https://www.javamadesoeasy.com/2015/05/exception-handling-exception-hierarchy.html)

- Checked Exception (Exception)
  - 컴파일시에 발생하는 에러
  - 반드시 예외처리 해야 함 (try-catch 이용하여)
　
<br>
　
- Unchecked Exception
  - RuntimeException (실행시 발생하는 에러)
  - 컴파일 과정 중 확인할 수 없는 에러
  - 명시적인 처리를 강제하지 않음
　
<br>
　
- [참고](https://www.nextree.co.kr/p3239/)

### 특수 사례 패턴 (Special Case Pattern)
- 클래스를 만들거나 객체를 조작해 특수 사례를 처리하는 방식
- 클래스나 객체가 예외적인 상황을 캡슐화해서 처리 → 클라이언트 코드가 예외 상황 처리할 필요 없어짐
  
책 예시의 ExpenseReportDAO 클래스 내에서 특이 케이스인지를 검사하는 속성을 추가하면 된다!

```java
// 이런 느낌으로 특이 케이스인지 검사하고 특이 케이스인 경우 해당 케이스에 대한 처리를 해준다

public class ExpenseReportDAO {
    // ...

    public MealExpenses getMeals(int employeeID) {
        // 특수한 경우인지 확인
        if (/* 특수한 경우를 확인하는 조건 */) {
            return new PerDiemMealExpenses();
        } else {
            // 일반적인 경우의 처리
            // ...
        }
    }

    // ...
}
```

- [참고하면 좋은 블로그](https://velog.io/@yeahg_dev/Special-Case-Pattern)


이 장의 결론에서 **오류 처리를 프로그램 논리와 분리해 독자적인 사안으로 고려**하라고 했다. 코드를 짜면서 해당 부분이 논리에 포함되는지 오류 처리를 하는 부분인지 구분하는 노력을 해야할 것 같다!
그리고 특수 사례 패턴을 활용할 수 있는 부분이 있다면 이 부분을 잘 활용해봐야겠다 🖌

---

## Chapter 8. 경계
- 패키지 및 프레임워크 제공자 : 적용성을 최대한 넓히려고 함 (더 많은 환경에서 돌아가야해서)
- 사용자 : 자신의 요구에 집중하는 인터페이스를 원함

이 차이로 인해 시스템 경계는 문제가 생길 소지가 많음! <br>
아래의 예시와 같이 경계 인터페이스를 캡슐화하면 좋음!
- 캡슐화해서 사용하면 경계 인터페이스가 변경되더라도 다른 부분에 영향을 미치지 않음
- 캡슐화해서 사용했기 때문에 필요한 기능만 제공할 수 있음!

```java
public class Sensors {
  private Map sensors = new HashMap( );
  public Sensor getById(String id) {
    return (Sensor) sensors.get(id);
  }
   // 이 하 생 략
}
```
예시에서는 Sensors 클래스 내부에서 객체 유형을 관리하고 변환 → 외부에서 Map 인터페이스의 변화에 대해 신경 쓰지 않아도 됨
- 경계 인터페이스를 이용할 때는 이를 이용하는 클래스 밖으로 노출되지 않도록 주의하기!
　
<br>
　
- 경계 인터페이스?
  - 소프트웨어 시스템 내에서 외부와의 상호작용을 담당하는 인터페이스를 의미
  - 주로 시스템 내부와 외부 간의 상호작용을 담당하는 인터페이스
　
<br>
　
- 소프트웨어 경계
  - 컴포넌트 간 경계
    - 서로 다른 기능을 수행하는 컴포넌트 또는 모듈 간의 경계를 의미
    - 경계는 모듈 간의 인터페이스로 정의됨
  - 시스템 간 경계
    - 소프트웨어 시스템과 외부 시스템 또는 서비스 간의 경계를 의미
    - 다른 시스템과의 상호 작용을 위해 표준 인터페이스, 웹 서비스, API 등을 사용하여 데이터 교환, 통신, 통합을 수행
  - 계층 간 경계
    - 소프트웨어 시스템 내에서 다른 계층 간의 경계를 의미
    - 클라이언트-서버 아키텍처에서 클라이언트와 서버 간의 경계를 나타내는 것

여기의 경계 관련된 글은 구글에 검색했을 때 딱히 나오지는 않았으나 chat gpt가 알려준 내용이다...! 그래서 엄청 신뢰성이 있는지는 잘 ...! 🙊


---

## Chapter 10. 클래스
- 클래스는 작아야 함!
  - 클래스가 맡은 책임은 한개여야 함!

- 클래스 이름 : 해당 클래스 책임을 기술하기
- 클래스 설명 : if, and, or, but 등을 사용하지 않고 25 단어 내외로 설명 가능해야 함!

#### 응집도
- 클래스는 인스턴스 변수 수가 작아야 함
- 메소드가 변수를 더 많이 사용할수록 메소드와 클래스는 응집도가 크다
- 때때로 몇몇 메소드만이 사용하는 인스턴스 변수가 많아지는데 이 때가 새로운 클래스로 쪼개야 한다는 신호!

#### 변경하기 쉬운 클래스
- OCP(Open-Closed Principle)를 만족하는 클래스!
- 기능을 추가하거나 기존 기능을 변경할 때 건드릴 코드가 최소인 시스템 구조가 바람직
- 이상적인 시스템이라면 기능 추가 시 시스템을 확장할 뿐 기존 코드를 변경하지 않는다

책에서 **이상적인 시스템이라면 기능 추가 시 시스템을 확장할 뿐 기존 코드를 변경하지 않는다** 라고 했다. 내가 짠 코드를 생각하니 기능 추가 시 기존 코드를 수정했던 경우가 많았던 것 같다 🥹 클래스를 잘 쪼개고 구조를 잘 짜도록 노력해야지.. 🥲

<br>
